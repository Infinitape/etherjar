buildscript {
    repositories {
        maven { url "https://dl.bintray.com/nebula/gradle-plugins" }
    }

    dependencies {
        classpath 'com.netflix.nebula:gradle-aggregate-javadocs-plugin:3.0.1'
    }
}

plugins {
    id "com.jfrog.bintray" version "1.8.4"
}

// gradle aggregateJavadoc
apply plugin: 'nebula-aggregate-javadocs'
apply plugin: 'jacoco'

allprojects {
    group = 'io.infinitape'
    version = "0.11.0-SNAPSHOT"

    repositories {
        mavenLocal()
        mavenCentral()
        jcenter()
        maven { url 'https://oss.jfrog.org/artifactory/repo' }
    }
}

def pomConfig = {
    licenses {
        license {
            name "The Apache Software License, Version 2.0"
            url "http://www.apache.org/licenses/LICENSE-2.0.txt"
            distribution "repo"
        }
    }
    developers {
        developer {
            id "splix"
            name "Igor Artamonov"
            email "igor@artamonov.ru"
        }
    }

    scm {
        connection "scm:git:git://github.com/emeraldpay/etherjar.git"
        developerConnection "scm:git:git://github.com/emeraldpay/etherjar.git"
        url "https://github.com/emeraldpay/etherjar"
    }
}

subprojects {
    apply plugin: 'java'
    apply plugin: 'java-library'
    apply plugin: 'groovy'
    apply plugin: 'jacoco'
    apply plugin: 'maven'
    apply plugin: 'maven-publish'
    apply plugin: 'com.jfrog.bintray'

    targetCompatibility = '1.8'
    sourceCompatibility = '1.8'

    [compileJava, compileTestJava]*.options*.encoding = 'UTF-8'

    compileJava.options.compilerArgs \
        << '-Xlint:unchecked' << '-Xlint:deprecation'

    dependencies {
        testCompile 'org.objenesis:objenesis:2.+'
        testCompile 'org.spockframework:spock-core:1.3-groovy-2.5'
        testCompile 'nl.jqno.equalsverifier:equalsverifier:3.1.9'
        testCompile 'org.codehaus.groovy:groovy-all:2.5.12'
    }

    test {
        jvmArgs '-ea'

        testLogging.showStandardStreams = true
        testLogging.exceptionFormat = 'full'
    }

    jacocoTestReport {
        reports {
            xml.enabled true
        }
    }

    jacoco {
        toolVersion = "0.8.5"
    }

    test.finalizedBy jacocoTestReport

    // Show the list of failed tests and output only for them, helpful for CI
    ext.failedTests = []
    tasks.withType(Test) {
        def stdout = new LinkedList<String>()
        beforeTest { TestDescriptor td ->
            stdout.clear()
        }
        onOutput { TestDescriptor td, TestOutputEvent toe ->
            stdout.addAll(toe.getMessage().split('(?m)$'))
            while (stdout.size() > 100) {
                stdout.remove()
            }
        }
        afterTest { TestDescriptor descriptor, TestResult result ->
            if(result.resultType == org.gradle.api.tasks.testing.TestResult.ResultType.FAILURE){
                failedTests << "${descriptor.className} > ${descriptor.name}"
                if (!stdout.isEmpty()) {
                    println("-------- ${descriptor.className} > ${descriptor.name} OUTPUT ".padRight(120, "-"))
                    stdout.each { print(it) }
                    println("================".padRight(120, "="))
                }
            }
        }
    }
    gradle.buildFinished {
        if(!failedTests.empty){
            println "Failed tests for ${project.name}:"
            failedTests.each { failedTest ->
                println failedTest
            }
            println ""
        }
    }

    task sourcesJar(type: Jar, dependsOn: classes) {
        classifier = 'sources'
        from sourceSets.main.allSource
    }

    task javadocJar(type: Jar, dependsOn: javadoc) {
        classifier = 'javadoc'
        from javadoc.destinationDir
    }

    artifacts {
        archives sourcesJar
        archives javadocJar
    }

    publishing {
        publications {
            EtherJarPublication(MavenPublication) {
                from components.java
                artifact sourcesJar {
                    classifier "sources"
                }
                artifact javadocJar {
                    classifier "javadoc"
                }

                groupId project.group
                artifactId project.name
                version project.version
                pom.withXml {
                    def root = asNode()
                    root.appendNode('name', 'EtherJar - Java Library to Build Application on Ethereum')
                    root.children().last() + pomConfig
                }
            }
        }
    }

    bintray {
        user = System.getProperty('bintrayUser') ? System.getProperty('bintrayUser') : System.getenv('BINTRAY_USER')
        key = System.getProperty('bintrayApiKey') ? System.getProperty('bintrayApiKey') : System.getenv('BINTRAY_API_KEY')

        publications = ['EtherJarPublication']

        dryRun=false
        publish=true
        override=true

        pkg {
            repo = 'etherjar'
            userOrg = 'infinitape'
            name = project.name
            licenses = ['Apache-2.0']
            vcsUrl = 'https://github.com/emeraldpay/etherjar.git'
            labels = ['ethereum', 'blockchain', 'smart-contracts', 'java-8']
            publicDownloadNumbers = true

            version {
                name = project.version
                description = 'EtherJar ' + project.version + ' Beta'
                released  = new Date()
                vcsTag = project.version

                gpg {
                    sign = true
                }
            }
        }
    }
}

// Skip Bintray for the root module
bintray {
    dryRun=true
    publish=false
    override=true
    publications = []
    configurations = []
    pkg {
        repo = 'none'
        name = 'none'
        version {
            name = 'none'
        }
    }
}

task syncJars(type: Sync) {
    allprojects { p ->
        from p.tasks.withType(Jar)
    }
    into "${buildDir}/libs/"
}

jacoco {
    toolVersion = "0.8.5"
}

task coverageReport(type: JacocoReport) {
    dependsOn = subprojects.test
    additionalSourceDirs.setFrom files(subprojects.sourceSets.main.allSource.srcDirs)
    sourceDirectories.setFrom files(subprojects.sourceSets.main.allSource.srcDirs)
    classDirectories.setFrom files(subprojects.sourceSets.main.output)
    executionData.setFrom project.fileTree(dir: '.', include: '**/build/jacoco/test.exec')
    reports {
        xml.enabled true
        csv.enabled false
        html.enabled true
    }
}
